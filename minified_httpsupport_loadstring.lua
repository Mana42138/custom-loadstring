local a={}local b={}local c={}local d={}local e={}local f={}local g={}local h=select;local i=string.byte;local j=string.sub;local k={'ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local function l(m,n,o)if o then local p=m/2^(n-1)%2^(o-1-(n-1)+1)return p-p%1 else local q=2^(n-1)if m%(q+q)>=q then return 1 else return 0 end end end;local function r(s)local t=1;local u;local v;local function w()local x=i(s,t,t)t=t+1;return x end;local function y()local z,A,B,C=i(s,t,t+3)t=t+4;return C*16777216+B*65536+A*256+z end;local function D()return y()*4294967296+y()end;local function E()local F=y()local G=y()local H=1;local I=l(G,1,20)*2^32+F;local J=l(G,21,31)local K=(-1)^l(G,32)if J==0 then if I==0 then return K*0 else J=1;H=0 end elseif J==2047 then if I==0 then return K*1/0 else return K*0/0 end end;return math.ldexp(K,J-1023)*(H+I/2^52)end;local function L(M)local N;if M then N=j(s,t,t+M-1)t=t+M else M=u()if M==0 then return end;N=j(s,t,t+M-1)t=t+M end;return N end;local function O()local P={}local Q={}local R={}local S={Instr=P,Const=Q,Proto=R,Lines={},Name=L(),FirstL=v(),LastL=v(),Upvals=w(),Args=w(),Vargs=w(),Stack=w()}if S.Name then S.Name=j(S.Name,1,-2)end;for T=1,v()do local U=y()local V=l(U,1,6)local W=k[V+1]local X;if W then X={Enum=V,l(U,7,14)}if W=='ABC'then X[2]=l(U,24,32)X[3]=l(U,15,23)elseif W=='ABx'then X[2]=l(U,15,32)elseif W=='AsBx'then X[2]=l(U,15,32)-131071 end else X=U end;P[T]=X end;for T=1,v()do local W=w()local Y;if W==1 then Y=w()~=0 elseif W==3 then Y=E()elseif W==4 then Y=j(L(),1,-2)end;Q[T-1]=Y end;for T=1,v()do R[T-1]=O()end;do local Z=S.Lines;for T=1,v()do Z[T]=y()end;for _=1,v()do L()y()y()end;for _=1,v()do L()end end;return S end;do assert(L(4)=="\27Lua","Lua bytecode expected.")assert(w()==0x51,"Only Lua 5.1 is supported.")w()w()local a0=w()local a1=w()if a0==4 then v=y elseif a0==8 then v=D else error('Integer size not supported',2)end;if a1==4 then u=y elseif a1==8 then u=D else error('Sizet size not supported',2)end;assert(L(3)=="\4\8\0","Unsupported bytecode target platform")end;return O()end;local function a2(...)return h('#',...),{...}end;local function a3(S,a4,a5)local P=S.Instr;local Q=S.Const;local R=S.Proto;local function a6(a7,a8)local a9=S.Name or'Code'local aa=S.Lines[a8]or'?'a7=tostring(a7):match'^.+:%s*(.+)'or a7;error(string.format('%s (%s): %s',a9,aa,a7),0)end;return function(...)local ab,ac=1,-1;local ad,ae={},h('#',...)-1;local af={}local ag={}local ah=setmetatable({},{__index=af,__newindex=function(_,ai,aj)if ai>ac then ac=ai end;af[ai]=aj end})local function ak()local X,al;while true do X=P[ab]al=X.Enum;ab=ab+1;if al==0 then ah[X[1]]=ah[X[2]]elseif al==1 then ah[X[1]]=Q[X[2]]elseif al==2 then ah[X[1]]=X[2]~=0;if X[3]~=0 then ab=ab+1 end elseif al==3 then local am=ah;for T=X[1],X[2]do am[T]=nil end elseif al==4 then ah[X[1]]=a5[X[2]]elseif al==5 then ah[X[1]]=a4[Q[X[2]]]elseif al==6 then local an=X[3]local am=ah;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]]=am[X[2]][an]elseif al==7 then a4[Q[X[2]]]=ah[X[1]]elseif al==8 then a5[X[2]]=ah[X[1]]elseif al==9 then local ao,an=X[2],X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]][ao]=an elseif al==10 then ah[X[1]]={}elseif al==11 then local ap=X[1]local ao=X[2]local an=X[3]local am=ah;ao=am[ao]if an>255 then an=Q[an-256]else an=am[an]end;am[ap+1]=ao;am[ap]=ao[an]elseif al==12 then local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]]=ao+an elseif al==13 then local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]]=ao-an elseif al==14 then local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]]=ao*an elseif al==15 then local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]]=ao/an elseif al==16 then local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]]=ao%an elseif al==17 then local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;am[X[1]]=ao^an elseif al==18 then ah[X[1]]=-ah[X[2]]elseif al==19 then ah[X[1]]=not ah[X[2]]elseif al==20 then ah[X[1]]=#ah[X[2]]elseif al==21 then local am=ah;local ao=X[2]local aq=am[ao]for T=ao+1,X[3]do aq=aq..am[T]end;ah[X[1]]=aq elseif al==22 then ab=ab+X[2]elseif al==23 then local ap=X[1]~=0;local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;if ao==an~=ap then ab=ab+1 end elseif al==24 then local ap=X[1]~=0;local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;if ao<an~=ap then ab=ab+1 end elseif al==25 then local ap=X[1]~=0;local ao=X[2]local an=X[3]local am=ah;if ao>255 then ao=Q[ao-256]else ao=am[ao]end;if an>255 then an=Q[an-256]else an=am[an]end;if ao<=an~=ap then ab=ab+1 end elseif al==26 then if not not ah[X[1]]==(X[3]==0)then ab=ab+1 end elseif al==27 then local ao=ah[X[2]]if not not ao==(X[3]==0)then ab=ab+1 else ah[X[1]]=ao end elseif al==28 then local ap=X[1]local ao=X[2]local an=X[3]local am=ah;local ar,as;local at,ak;ar={}if ao~=1 then if ao~=0 then at=ap+ao-1 else at=ac end;ak=0;for T=ap+1,at do ak=ak+1;ar[ak]=am[T]end;at,as=a2(am[ap](unpack(ar,1,at-ap)))else at,as=a2(am[ap]())end;ac=ap-1;if an~=1 then if an~=0 then at=ap+an-2 else at=at+ap-1 end;ak=0;for T=ap,at do ak=ak+1;am[T]=as[ak]end end elseif al==29 then local ap=X[1]local ao=X[2]local am=ah;local ar,as;local at,ak;local au=0;ar={}if ao~=1 then if ao~=0 then at=ap+ao-1 else at=ac end;ak=0;for T=ap+1,at do ak=ak+1;ar[#ar+1]=am[T]end;as={am[ap](unpack(ar,1,at-ap))}else as={am[ap]()}end;for av in next,as do if av>au then au=av end end;return as,au elseif al==30 then local ap=X[1]local ao=X[2]local am=ah;local ak,aw;local at;if ao==1 then return elseif ao==0 then at=ac else at=ap+ao-2 end;aw={}ak=0;for T=ap,at do ak=ak+1;aw[ak]=am[T]end;return aw,ak elseif al==31 then local ap=X[1]local am=ah;local ax=am[ap+2]local av=am[ap]+ax;am[ap]=av;if ax>0 then if av<=am[ap+1]then ab=ab+X[2]am[ap+3]=av end else if av>=am[ap+1]then ab=ab+X[2]am[ap+3]=av end end elseif al==32 then local ap=X[1]local am=ah;am[ap]=assert(tonumber(am[ap]),'`for` initial value must be a number')am[ap+1]=assert(tonumber(am[ap+1]),'`for` limit must be a number')am[ap+2]=assert(tonumber(am[ap+2]),'`for` step must be a number')am[ap]=am[ap]-am[ap+2]ab=ab+X[2]elseif al==33 then local ap=X[1]local an=X[3]local am=ah;local ay=ap+2;local az={am[ap](am[ap+1],am[ap+2])}for T=1,an do ah[ay+T]=az[T]end;if am[ap+3]~=nil then am[ap+2]=am[ap+3]else ab=ab+1 end elseif al==34 then local ap=X[1]local ao=X[2]local an=X[3]local am=ah;if an==0 then ab=ab+1;an=P[ab]end;local ay=(an-1)*50;local aA=am[ap]if ao==0 then ao=ac end;for T=1,ao do aA[ay+T]=am[ap+T]end elseif al==35 then local ap=X[1]local aB={}for T=1,#ag do local aC=ag[T]for aD=0,#aC do local aE=aC[aD]local am=aE[1]local t=aE[2]if am==ah and t>=ap then aB[t]=am[t]aE[1]=aB end end end elseif al==36 then local aF=R[X[2]]local am=ah;local aG;local aH;if aF.Upvals~=0 then aG={}aH=setmetatable({},{__index=function(_,ai)local aI=aG[ai]return aI[1][aI[2]]end,__newindex=function(_,ai,aj)local aI=aG[ai]aI[1][aI[2]]=aj end})for T=1,aF.Upvals do local aJ=P[ab]if aJ.Enum==0 then aG[T-1]={am,aJ[2]}elseif aJ.Enum==4 then aG[T-1]={a5,aJ[2]}end;ab=ab+1 end;ag[#ag+1]=aG end;am[X[1]]=a3(aF,a4,aH)elseif al==37 then local ap=X[1]local ao=X[2]local am,aK=ah,ad;ac=ap-1;for T=ap,ap+(ao>0 and ao-1 or ae)do am[T]=aK[T-ap]end end end end;local ar={...}for T=0,ae do if T>=S.Args then ad[T-S.Args]=ar[T+1]else ah[T]=ar[T+1]end end;local ap,ao,an=pcall(ak)if ap then if ao and an>0 then return unpack(ao,1,an)end;return else a6(ao,ab-1)end end end;function g:wrappermix(aL,a4)local aM=r(aL)return a3(aM,a4 or getfenv(0)),aM end;f.LUA_SIGNATURE="\27Lua"f.LUA_TNUMBER=3;f.LUA_TSTRING=4;f.LUA_TNIL=0;f.LUA_TBOOLEAN=1;f.LUA_TNONE=-1;f.LUAC_VERSION=0x51;f.LUAC_FORMAT=0;f.LUAC_HEADERSIZE=12;function f:make_setS()local aN={}aN.data=""local aO=function(aP,aN)if not aP then return 0 end;aN.data=aN.data..aP;return 0 end;return aO,aN end;function f:ttype(aQ)local aR=type(aQ.value)if aR=="number"then return self.LUA_TNUMBER elseif aR=="string"then return self.LUA_TSTRING elseif aR=="nil"then return self.LUA_TNIL elseif aR=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function f:from_double(aS)local function aT(aU)local aV=aU%256;return(aU-aV)/256,string.char(aV)end;local aW=0;if aS<0 then aW=1;aS=-aS end;local aX,aY=math.frexp(aS)if aS==0 then aX,aY=0,0 elseif aS==1/0 then aX,aY=0,2047 else aX=(aX*2-1)*math.ldexp(0.5,53)aY=aY+1022 end;local aU,aZ=""aS=math.floor(aX)for a_=1,6 do aS,aZ=aT(aS)aU=aU..aZ end;aS,aZ=aT(aY*16+aS)aU=aU..aZ;aS,aZ=aT(aW*128+aS)aU=aU..aZ;return aU end;function f:from_int(aS)local aU=""aS=math.floor(aS)if aS<0 then aS=4294967296+aS end;for a_=1,4 do local aV=aS%256;aU=aU..string.char(aV)aS=math.floor(aS/256)end;return aU end;function f:DumpBlock(b0,b1)if b1.status==0 then b1.status=b1.write(b0,b1.data)end end;function f:DumpChar(b2,b1)self:DumpBlock(string.char(b2),b1)end;function f:DumpInt(aS,b1)self:DumpBlock(self:from_int(aS),b1)end;function f:DumpNumber(aS,b1)self:DumpBlock(self:from_double(aS),b1)end;function f:DumpString(aP,b1)if aP==nil then self:DumpInt(0,b1)else aP=aP.."\0"self:DumpInt(#aP,b1)self:DumpBlock(aP,b1)end end;function f:DumpCode(b3,b1)local b4=b3.sizecode;self:DumpInt(b4,b1)for a_=0,b4-1 do self:DumpBlock(e:Instruction(b3.code[a_]),b1)end end;function f:DumpConstants(b3,b1)local b4=b3.sizek;self:DumpInt(b4,b1)for a_=0,b4-1 do local aQ=b3.k[a_]local aR=self:ttype(aQ)self:DumpChar(aR,b1)if aR==self.LUA_TNIL then elseif aR==self.LUA_TBOOLEAN then self:DumpChar(aQ.value and 1 or 0,b1)elseif aR==self.LUA_TNUMBER then self:DumpNumber(aQ.value,b1)elseif aR==self.LUA_TSTRING then self:DumpString(aQ.value,b1)else end end;b4=b3.sizep;self:DumpInt(b4,b1)for a_=0,b4-1 do self:DumpFunction(b3.p[a_],b3.source,b1)end end;function f:DumpDebug(b3,b1)local b4;b4=b1.strip and 0 or b3.sizelineinfo;self:DumpInt(b4,b1)for a_=0,b4-1 do self:DumpInt(b3.lineinfo[a_],b1)end;b4=b1.strip and 0 or b3.sizelocvars;self:DumpInt(b4,b1)for a_=0,b4-1 do self:DumpString(b3.locvars[a_].varname,b1)self:DumpInt(b3.locvars[a_].startpc,b1)self:DumpInt(b3.locvars[a_].endpc,b1)end;b4=b1.strip and 0 or b3.sizeupvalues;self:DumpInt(b4,b1)for a_=0,b4-1 do self:DumpString(b3.upvalues[a_],b1)end end;function f:DumpFunction(b3,b5,b1)local b6=b3.source;if b6==b5 or b1.strip then b6=nil end;self:DumpString(b6,b1)self:DumpInt(b3.lineDefined,b1)self:DumpInt(b3.lastlinedefined,b1)self:DumpChar(b3.nups,b1)self:DumpChar(b3.numparams,b1)self:DumpChar(b3.is_vararg,b1)self:DumpChar(b3.maxstacksize,b1)self:DumpCode(b3,b1)self:DumpConstants(b3,b1)self:DumpDebug(b3,b1)end;function f:DumpHeader(b1)local b7=self:header()assert(#b7==self.LUAC_HEADERSIZE)self:DumpBlock(b7,b1)end;function f:header()local aS=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,aS,4,4,4,8,0)end;function f:dump(b8,b3,b9,ba,bb)local b1={}b1.L=b8;b1.write=b9;b1.data=ba;b1.strip=bb;b1.status=0;self:DumpHeader(b1)self:DumpFunction(b3,nil,b1)b1.write(nil,b1.data)return b1.status end;e.OpMode={iABC=0,iABx=1,iAsBx=2}e.SIZE_C=9;e.SIZE_B=9;e.SIZE_Bx=e.SIZE_C+e.SIZE_B;e.SIZE_A=8;e.SIZE_OP=6;e.POS_OP=0;e.POS_A=e.POS_OP+e.SIZE_OP;e.POS_C=e.POS_A+e.SIZE_A;e.POS_B=e.POS_C+e.SIZE_C;e.POS_Bx=e.POS_C;e.MAXARG_Bx=math.ldexp(1,e.SIZE_Bx)-1;e.MAXARG_sBx=math.floor(e.MAXARG_Bx/2)e.MAXARG_A=math.ldexp(1,e.SIZE_A)-1;e.MAXARG_B=math.ldexp(1,e.SIZE_B)-1;e.MAXARG_C=math.ldexp(1,e.SIZE_C)-1;function e:GET_OPCODE(a_)return self.ROpCode[a_.OP]end;function e:SET_OPCODE(a_,aQ)a_.OP=self.OpCode[aQ]end;function e:GETARG_A(a_)return a_.A end;function e:SETARG_A(a_,bc)a_.A=bc end;function e:GETARG_B(a_)return a_.B end;function e:SETARG_B(a_,b0)a_.B=b0 end;function e:GETARG_C(a_)return a_.C end;function e:SETARG_C(a_,b0)a_.C=b0 end;function e:GETARG_Bx(a_)return a_.Bx end;function e:SETARG_Bx(a_,b0)a_.Bx=b0 end;function e:GETARG_sBx(a_)return a_.Bx-self.MAXARG_sBx end;function e:SETARG_sBx(a_,b0)a_.Bx=b0+self.MAXARG_sBx end;function e:CREATE_ABC(aQ,bd,b0,aV)return{OP=self.OpCode[aQ],A=bd,B=b0,C=aV}end;function e:CREATE_ABx(aQ,bd,be)return{OP=self.OpCode[aQ],A=bd,Bx=be}end;function e:CREATE_Inst(aV)local aQ=aV%64;aV=(aV-aQ)/64;local bd=aV%256;aV=(aV-bd)/256;return self:CREATE_ABx(aQ,bd,aV)end;function e:Instruction(a_)if a_.Bx then a_.C=a_.Bx%512;a_.B=(a_.Bx-a_.C)/512 end;local bf=a_.A*64+a_.OP;local bg=bf%256;bf=a_.C*64+(bf-bg)/256;local bh=bf%256;bf=a_.B*128+(bf-bh)/256;local bi=bf%256;local bj=(bf-bi)/256;return string.char(bg,bh,bi,bj)end;function e:DecodeInst(aS)local aZ=string.byte;local a_={}local bf=aZ(aS,1)local bk=bf%64;a_.OP=bk;bf=aZ(aS,2)*4+(bf-bk)/64;local bd=bf%256;a_.A=bd;bf=aZ(aS,3)*4+(bf-bd)/256;local aV=bf%512;a_.C=aV;a_.B=aZ(aS,4)*2+(bf-aV)/512;local bl=self.OpMode[tonumber(string.sub(self.opmodes[bk+1],7,7))]if bl~="iABC"then a_.Bx=a_.B*512+a_.C end;return a_ end;e.BITRK=math.ldexp(1,e.SIZE_B-1)function e:ISK(aS)return aS>=self.BITRK end;function e:INDEXK(aS)return aS-self.BITRK end;e.MAXINDEXRK=e.BITRK-1;function e:RKASK(aS)return aS+self.BITRK end;e.NO_REG=e.MAXARG_A;e.opnames={}e.OpCode={}e.ROpCode={}local a_=0;for aU in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],"%S+")do local b4="OP_"..aU;e.opnames[a_]=aU;e.OpCode[b4]=a_;e.ROpCode[a_]=b4;a_=a_+1 end;e.NUM_OPCODES=a_;e.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function e:getOpMode(bm)return self.opmodes[self.OpCode[bm]]%4 end;function e:getBMode(bm)return math.floor(self.opmodes[self.OpCode[bm]]/16)%4 end;function e:getCMode(bm)return math.floor(self.opmodes[self.OpCode[bm]]/4)%4 end;function e:testAMode(bm)return math.floor(self.opmodes[self.OpCode[bm]]/64)%2 end;function e:testTMode(bm)return math.floor(self.opmodes[self.OpCode[bm]]/128)end;e.LFIELDS_PER_FLUSH=50;local function bl(bn,bd,b0,aV,bm)local e=e;return bn*128+bd*64+e.OpArgMask[b0]*16+e.OpArgMask[aV]*4+e.OpMode[bm]end;e.opmodes={bl(0,1,"OpArgK","OpArgN","iABx"),bl(0,1,"OpArgU","OpArgU","iABC"),bl(0,1,"OpArgR","OpArgN","iABC"),bl(0,1,"OpArgU","OpArgN","iABC"),bl(0,1,"OpArgK","OpArgN","iABx"),bl(0,1,"OpArgR","OpArgK","iABC"),bl(0,0,"OpArgK","OpArgN","iABx"),bl(0,0,"OpArgU","OpArgN","iABC"),bl(0,0,"OpArgK","OpArgK","iABC"),bl(0,1,"OpArgU","OpArgU","iABC"),bl(0,1,"OpArgR","OpArgK","iABC"),bl(0,1,"OpArgK","OpArgK","iABC"),bl(0,1,"OpArgK","OpArgK","iABC"),bl(0,1,"OpArgK","OpArgK","iABC"),bl(0,1,"OpArgK","OpArgK","iABC"),bl(0,1,"OpArgK","OpArgK","iABC"),bl(0,1,"OpArgK","OpArgK","iABC"),bl(0,1,"OpArgR","OpArgN","iABC"),bl(0,1,"OpArgR","OpArgN","iABC"),bl(0,1,"OpArgR","OpArgN","iABC"),bl(0,1,"OpArgR","OpArgR","iABC"),bl(0,0,"OpArgR","OpArgN","iAsBx"),bl(1,0,"OpArgK","OpArgK","iABC"),bl(1,0,"OpArgK","OpArgK","iABC"),bl(1,0,"OpArgK","OpArgK","iABC"),bl(1,1,"OpArgR","OpArgU","iABC"),bl(1,1,"OpArgR","OpArgU","iABC"),bl(0,1,"OpArgU","OpArgU","iABC"),bl(0,1,"OpArgU","OpArgU","iABC"),bl(0,0,"OpArgU","OpArgN","iABC"),bl(0,1,"OpArgR","OpArgN","iAsBx"),bl(0,1,"OpArgR","OpArgN","iAsBx"),bl(1,0,"OpArgN","OpArgU","iABC"),bl(0,0,"OpArgU","OpArgU","iABC"),bl(0,0,"OpArgN","OpArgN","iABC"),bl(0,1,"OpArgU","OpArgN","iABx"),bl(0,1,"OpArgU","OpArgN","iABC")}e.opmodes[0]=bl(0,1,"OpArgR","OpArgN","iABC")function a:make_getS(aN)local b0=aN;return function()if not b0 then return nil end;local ba=b0;b0=nil;return ba end end;function a:init(bo,ba,bp)if not bo then return end;local bq={}bq.reader=bo;bq.data=ba or""bq.name=bp;if not ba or ba==""then bq.n=0 else bq.n=#ba end;bq.p=0;return bq end;function a:fill(bq)local aN=bq.reader()bq.data=aN;if not aN or aN==""then return"EOZ"end;bq.n,bq.p=#aN-1,1;return string.sub(aN,1,1)end;function a:zgetc(bq)local b4,b5=bq.n,bq.p+1;if b4>0 then bq.n,bq.p=b4-1,b5;return string.sub(bq.data,b5,b5)else return self:fill(bq)end end;b.RESERVED=[[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]b.MAXSRC=80;b.MAX_INT=2147483645;b.LUA_QS="'%s'"b.LUA_COMPAT_LSTR=1;function b:init()local br,bs={},{}for aU in string.gmatch(self.RESERVED,"[^\n]+")do local _,_,bt,bu=string.find(aU,"(%S+)%s+(%S+)")br[bt]=bu;bs[bu]=bt end;self.tokens=br;self.enums=bs end;function b:chunkid(b6,bv)local bw;local bx=string.sub(b6,1,1)if bx=="="then bw=string.sub(b6,2,bv)else if bx=="@"then b6=string.sub(b6,2)bv=bv-#" '...' "local by=#b6;bw=""if by>bv then b6=string.sub(b6,1+by-bv)bw=bw.."..."end;bw=bw..b6 else local bz=string.find(b6,"[\n\r]")bz=bz and bz-1 or#b6;bv=bv-#" [string \"...\"] "if bz>bv then bz=bv end;bw="[string \""if bz<#b6 then bw=bw..string.sub(b6,1,bz).."..."else bw=bw..b6 end;bw=bw.."\"]"end end;return bw end;function b:token2str(bA,bB)if string.sub(bB,1,3)~="TK_"then if string.find(bB,"%c")then return string.format("char(%d)",string.byte(bB))end;return bB else end;return self.tokens[bB]end;function b:lexerror(bA,bC,bB)local function bD(bA,bB)if bB=="TK_NAME"or bB=="TK_STRING"or bB=="TK_NUMBER"then return bA.buff else return self:token2str(bA,bB)end end;local aN=self:chunkid(bA.source,self.MAXSRC)local bC=string.format("%s:%d: %s",aN,bA.linenumber,bC)if bB then bC=string.format("%s near "..self.LUA_QS,bC,bD(bA,bB))end;error(bC)end;function b:syntaxerror(bA,bC)self:lexerror(bA,bC,bA.t.token)end;function b:currIsNewline(bA)return bA.current=="\n"or bA.current=="\r"end;function b:inclinenumber(bA)local bE=bA.current;self:nextc(bA)if self:currIsNewline(bA)and bA.current~=bE then self:nextc(bA)end;bA.linenumber=bA.linenumber+1;if bA.linenumber>=self.MAX_INT then self:syntaxerror(bA,"chunk has too many lines")end end;function b:setinput(b8,bA,bq,b6)if not bA then bA={}end;if not bA.lookahead then bA.lookahead={}end;if not bA.t then bA.t={}end;bA.decpoint="."bA.L=b8;bA.lookahead.token="TK_EOS"bA.z=bq;bA.fs=nil;bA.linenumber=1;bA.lastline=1;bA.source=b6;self:nextc(bA)end;function b:check_next(bA,bF)if not string.find(bF,bA.current,1,1)then return false end;self:save_and_next(bA)return true end;function b:next(bA)bA.lastline=bA.linenumber;if bA.lookahead.token~="TK_EOS"then bA.t.seminfo=bA.lookahead.seminfo;bA.t.token=bA.lookahead.token;bA.lookahead.token="TK_EOS"else bA.t.token=self:llex(bA,bA.t)end end;function b:lookahead(bA)bA.lookahead.token=self:llex(bA,bA.lookahead)end;function b:nextc(bA)local aV=a:zgetc(bA.z)bA.current=aV;return aV end;function b:save(bA,aV)local aN=bA.buff;bA.buff=aN..aV end;function b:save_and_next(bA)self:save(bA,bA.current)return self:nextc(bA)end;function b:str2d(aP)local bG=tonumber(aP)if bG then return bG end;if string.lower(string.sub(aP,1,2))=="0x"then bG=tonumber(aP,16)if bG then return bG end end;return nil end;function b:buffreplace(bA,bH,bI)local bG,aN="",bA.buff;for b5=1,#aN do local aV=string.sub(aN,b5,b5)if aV==bH then aV=bI end;bG=bG..aV end;bA.buff=bG end;function b:trydecpoint(bA,bJ)local bE=bA.decpoint;self:buffreplace(bA,bE,bA.decpoint)local bK=self:str2d(bA.buff)bJ.seminfo=bK;if not bK then self:buffreplace(bA,bA.decpoint,".")self:lexerror(bA,"malformed number","TK_NUMBER")end end;function b:read_numeral(bA,bJ)repeat self:save_and_next(bA)until string.find(bA.current,"%D")and bA.current~="."if self:check_next(bA,"Ee")then self:check_next(bA,"+-")end;while string.find(bA.current,"^%w$")or bA.current=="_"do self:save_and_next(bA)end;self:buffreplace(bA,".",bA.decpoint)local bK=self:str2d(bA.buff)bJ.seminfo=bK;if not bK then self:trydecpoint(bA,bJ)end end;function b:skip_sep(bA)local bL=0;local aP=bA.current;self:save_and_next(bA)while bA.current=="="do self:save_and_next(bA)bL=bL+1 end;return bA.current==aP and bL or-bL-1 end;function b:read_long_string(bA,bJ,bM)local bN=0;self:save_and_next(bA)if self:currIsNewline(bA)then self:inclinenumber(bA)end;while true do local aV=bA.current;if aV=="EOZ"then self:lexerror(bA,bJ and"unfinished long string"or"unfinished long comment","TK_EOS")elseif aV=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(bA)==bM then self:save_and_next(bA)bN=bN+1;if self.LUA_COMPAT_LSTR==1 then if bM==0 then self:lexerror(bA,"nesting of [[...]] is deprecated","[")end end end end elseif aV=="]"then if self:skip_sep(bA)==bM then self:save_and_next(bA)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then bN=bN-1;if bM==0 and bN>=0 then break end end;break end elseif self:currIsNewline(bA)then self:save(bA,"\n")self:inclinenumber(bA)if not bJ then bA.buff=""end else if bJ then self:save_and_next(bA)else self:nextc(bA)end end end;if bJ then local b5=3+bM;bJ.seminfo=string.sub(bA.buff,b5,-b5)end end;function b:read_string(bA,bO,bJ)self:save_and_next(bA)while bA.current~=bO do local aV=bA.current;if aV=="EOZ"then self:lexerror(bA,"unfinished string","TK_EOS")elseif self:currIsNewline(bA)then self:lexerror(bA,"unfinished string","TK_STRING")elseif aV=="\\"then aV=self:nextc(bA)if self:currIsNewline(bA)then self:save(bA,"\n")self:inclinenumber(bA)elseif aV~="EOZ"then local a_=string.find("abfnrtv",aV,1,1)if a_ then self:save(bA,string.sub("\a\b\f\n\r\t\v",a_,a_))self:nextc(bA)elseif not string.find(aV,"%d")then self:save_and_next(bA)else aV,a_=0,0;repeat aV=10*aV+bA.current;self:nextc(bA)a_=a_+1 until a_>=3 or not string.find(bA.current,"%d")if aV>255 then self:lexerror(bA,"escape sequence too large","TK_STRING")end;self:save(bA,string.char(aV))end end else self:save_and_next(bA)end end;self:save_and_next(bA)bJ.seminfo=string.sub(bA.buff,2,-2)end;function b:llex(bA,bJ)bA.buff=""while true do local aV=bA.current;if self:currIsNewline(bA)then self:inclinenumber(bA)elseif aV=="-"then aV=self:nextc(bA)if aV~="-"then return"-"end;local bM=-1;if self:nextc(bA)=='['then bM=self:skip_sep(bA)bA.buff=""end;if bM>=0 then self:read_long_string(bA,nil,bM)bA.buff=""else while not self:currIsNewline(bA)and bA.current~="EOZ"do self:nextc(bA)end end elseif aV=="["then local bM=self:skip_sep(bA)if bM>=0 then self:read_long_string(bA,bJ,bM)return"TK_STRING"elseif bM==-1 then return"["else self:lexerror(bA,"invalid long string delimiter","TK_STRING")end elseif aV=="="then aV=self:nextc(bA)if aV~="="then return"="else self:nextc(bA)return"TK_EQ"end elseif aV=="<"then aV=self:nextc(bA)if aV~="="then return"<"else self:nextc(bA)return"TK_LE"end elseif aV==">"then aV=self:nextc(bA)if aV~="="then return">"else self:nextc(bA)return"TK_GE"end elseif aV=="~"then aV=self:nextc(bA)if aV~="="then return"~"else self:nextc(bA)return"TK_NE"end elseif aV=="\""or aV=="'"then self:read_string(bA,aV,bJ)return"TK_STRING"elseif aV=="."then aV=self:save_and_next(bA)if self:check_next(bA,".")then if self:check_next(bA,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(aV,"%d")then return"."else self:read_numeral(bA,bJ)return"TK_NUMBER"end elseif aV=="EOZ"then return"TK_EOS"else if string.find(aV,"%s")then self:nextc(bA)elseif string.find(aV,"%d")then self:read_numeral(bA,bJ)return"TK_NUMBER"elseif string.find(aV,"[_%a]")then repeat aV=self:save_and_next(bA)until aV=="EOZ"or not string.find(aV,"[_%w]")local bP=bA.buff;local bt=self.enums[bP]if bt then return bt end;bJ.seminfo=bP;return"TK_NAME"else self:nextc(bA)return aV end end end end;c.LUA_QS=b.LUA_QS or"'%s'"c.SHRT_MAX=32767;c.LUAI_MAXVARS=200;c.LUAI_MAXUPVALUES=60;c.MAX_INT=b.MAX_INT or 2147483645;c.LUAI_MAXCCALLS=200;c.VARARG_HASARG=1;c.HASARG_MASK=2;c.VARARG_ISVARARG=2;c.VARARG_NEEDSARG=4;c.LUA_MULTRET=-1;function c:LUA_QL(aS)return"'"..aS.."'"end;function c:growvector(b8,aU,bQ,bR,bn,bS,bT)if bQ>=bS then error(bT)end end;function c:newproto(b8)local b3={}b3.k={}b3.sizek=0;b3.p={}b3.sizep=0;b3.code={}b3.sizecode=0;b3.sizelineinfo=0;b3.sizeupvalues=0;b3.nups=0;b3.upvalues={}b3.numparams=0;b3.is_vararg=0;b3.maxstacksize=0;b3.lineinfo={}b3.sizelocvars=0;b3.locvars={}b3.lineDefined=0;b3.lastlinedefined=0;b3.source=nil;return b3 end;function c:int2fb(aS)local bT=0;while aS>=16 do aS=math.floor((aS+1)/2)bT=bT+1 end;if aS<8 then return aS else return(bT+1)*8+aS-8 end end;function c:hasmultret(bU)return bU=="VCALL"or bU=="VVARARG"end;function c:getlocvar(bV,a_)return bV.f.locvars[bV.actvar[a_]]end;function c:checklimit(bV,aU,by,bm)if aU>by then self:errorlimit(bV,by,bm)end end;function c:anchor_token(bA)if bA.t.token=="TK_NAME"or bA.t.token=="TK_STRING"then end end;function c:error_expected(bA,bB)b:syntaxerror(bA,string.format(self.LUA_QS.." expected",b:token2str(bA,bB)))end;function c:errorlimit(bV,bS,bW)local bC=bV.f.linedefined==0 and string.format("main function has more than %d %s",bS,bW)or string.format("function at line %d has more than %d %s",bV.f.linedefined,bS,bW)b:lexerror(bV.ls,bC,0)end;function c:testnext(bA,aV)if bA.t.token==aV then b:next(bA)return true else return false end end;function c:check(bA,aV)if bA.t.token~=aV then self:error_expected(bA,aV)end end;function c:checknext(bA,aV)self:check(bA,aV)b:next(bA)end;function c:check_condition(bA,aV,bC)if not aV then b:syntaxerror(bA,bC)end end;function c:check_match(bA,bW,bX,bY)if not self:testnext(bA,bW)then if bY==bA.linenumber then self:error_expected(bA,bW)else b:syntaxerror(bA,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",b:token2str(bA,bW),b:token2str(bA,bX),bY))end end end;function c:str_checkname(bA)self:check(bA,"TK_NAME")local bP=bA.t.seminfo;b:next(bA)return bP end;function c:init_exp(bT,bU,a_)bT.f,bT.t=d.NO_JUMP,d.NO_JUMP;bT.k=bU;bT.info=a_ end;function c:codestring(bA,bT,aP)self:init_exp(bT,"VK",d:stringK(bA.fs,aP))end;function c:checkname(bA,bT)self:codestring(bA,bT,self:str_checkname(bA))end;function c:registerlocalvar(bA,bZ)local bV=bA.fs;local b3=bV.f;self:growvector(bA.L,b3.locvars,bV.nlocvars,b3.sizelocvars,nil,self.SHRT_MAX,"too many local variables")b3.locvars[bV.nlocvars]={}b3.locvars[bV.nlocvars].varname=bZ;local b_=bV.nlocvars;bV.nlocvars=bV.nlocvars+1;return b_ end;function c:new_localvarliteral(bA,aU,b4)self:new_localvar(bA,aU,b4)end;function c:new_localvar(bA,bp,b4)local bV=bA.fs;self:checklimit(bV,bV.nactvar+b4+1,self.LUAI_MAXVARS,"local variables")bV.actvar[bV.nactvar+b4]=self:registerlocalvar(bA,bp)end;function c:adjustlocalvars(bA,c0)local bV=bA.fs;bV.nactvar=bV.nactvar+c0;for a_=c0,1,-1 do self:getlocvar(bV,bV.nactvar-a_).startpc=bV.pc end end;function c:removevars(bA,c1)local bV=bA.fs;while bV.nactvar>c1 do bV.nactvar=bV.nactvar-1;self:getlocvar(bV,bV.nactvar).endpc=bV.pc end end;function c:indexupvalue(bV,bp,aU)local b3=bV.f;for a_=0,b3.nups-1 do if bV.upvalues[a_].k==aU.k and bV.upvalues[a_].info==aU.info then assert(b3.upvalues[a_]==bp)return a_ end end;self:checklimit(bV,b3.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(bV.L,b3.upvalues,b3.nups,b3.sizeupvalues,nil,self.MAX_INT,"")b3.upvalues[b3.nups]=bp;assert(aU.k=="VLOCAL"or aU.k=="VUPVAL")bV.upvalues[b3.nups]={k=aU.k,info=aU.info}local c2=b3.nups;b3.nups=b3.nups+1;return c2 end;function c:searchvar(bV,b4)for a_=bV.nactvar-1,0,-1 do if b4==self:getlocvar(bV,a_).varname then return a_ end end;return-1 end;function c:markupval(bV,c3)local c4=bV.bl;while c4 and c4.nactvar>c3 do c4=c4.previous end;if c4 then c4.upval=true end end;function c:singlevaraux(bV,b4,c5,c6)if bV==nil then self:init_exp(c5,"VGLOBAL",e.NO_REG)return"VGLOBAL"else local aU=self:searchvar(bV,b4)if aU>=0 then self:init_exp(c5,"VLOCAL",aU)if c6==0 then self:markupval(bV,aU)end;return"VLOCAL"else if self:singlevaraux(bV.prev,b4,c5,0)=="VGLOBAL"then return"VGLOBAL"end;c5.info=self:indexupvalue(bV,b4,c5)c5.k="VUPVAL"return"VUPVAL"end end end;function c:singlevar(bA,c5)local bZ=self:str_checkname(bA)local bV=bA.fs;if self:singlevaraux(bV,bZ,c5,1)=="VGLOBAL"then c5.info=d:stringK(bV,bZ)end end;function c:adjust_assign(bA,c0,c7,bT)local bV=bA.fs;local c8=c0-c7;if self:hasmultret(bT.k)then c8=c8+1;if c8<=0 then c8=0 end;d:setreturns(bV,bT,c8)if c8>1 then d:reserveregs(bV,c8-1)end else if bT.k~="VVOID"then d:exp2nextreg(bV,bT)end;if c8>0 then local c9=bV.freereg;d:reserveregs(bV,c8)d:_nil(bV,c9,c8)end end end;function c:enterlevel(bA)bA.L.nCcalls=bA.L.nCcalls+1;if bA.L.nCcalls>self.LUAI_MAXCCALLS then b:lexerror(bA,"chunk has too many syntax levels",0)end end;function c:leavelevel(bA)bA.L.nCcalls=bA.L.nCcalls-1 end;function c:enterblock(bV,c4,ca)c4.breaklist=d.NO_JUMP;c4.isbreakable=ca;c4.nactvar=bV.nactvar;c4.upval=false;c4.previous=bV.bl;bV.bl=c4;assert(bV.freereg==bV.nactvar)end;function c:leaveblock(bV)local c4=bV.bl;bV.bl=c4.previous;self:removevars(bV.ls,c4.nactvar)if c4.upval then d:codeABC(bV,"OP_CLOSE",c4.nactvar,0,0)end;assert(not c4.isbreakable or not c4.upval)assert(c4.nactvar==bV.nactvar)bV.freereg=bV.nactvar;d:patchtohere(bV,c4.breaklist)end;function c:pushclosure(bA,cb,aU)local bV=bA.fs;local b3=bV.f;self:growvector(bA.L,b3.p,bV.np,b3.sizep,nil,e.MAXARG_Bx,"constant table overflow")b3.p[bV.np]=cb.f;bV.np=bV.np+1;self:init_exp(aU,"VRELOCABLE",d:codeABx(bV,"OP_CLOSURE",0,bV.np-1))for a_=0,cb.f.nups-1 do local aQ=cb.upvalues[a_].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"d:codeABC(bV,aQ,0,cb.upvalues[a_].info,0)end end;function c:open_func(bA,bV)local b8=bA.L;local b3=self:newproto(bA.L)bV.f=b3;bV.prev=bA.fs;bV.ls=bA;bV.L=b8;bA.fs=bV;bV.pc=0;bV.lasttarget=-1;bV.jpc=d.NO_JUMP;bV.freereg=0;bV.nk=0;bV.np=0;bV.nlocvars=0;bV.nactvar=0;bV.bl=nil;b3.source=bA.source;b3.maxstacksize=2;bV.h={}end;function c:close_func(bA)local b8=bA.L;local bV=bA.fs;local b3=bV.f;self:removevars(bA,0)d:ret(bV,0,0)b3.sizecode=bV.pc;b3.sizelineinfo=bV.pc;b3.sizek=bV.nk;b3.sizep=bV.np;b3.sizelocvars=bV.nlocvars;b3.sizeupvalues=b3.nups;assert(bV.bl==nil)bA.fs=bV.prev;if bV then self:anchor_token(bA)end end;function c:parser(b8,bq,aN,bp)local cc={}cc.t={}cc.lookahead={}local cd={}cd.upvalues={}cd.actvar={}b8.nCcalls=0;cc.buff=aN;b:setinput(b8,cc,bq,bp)self:open_func(cc,cd)cd.f.is_vararg=self.VARARG_ISVARARG;b:next(cc)self:chunk(cc)self:check(cc,"TK_EOS")self:close_func(cc)assert(cd.prev==nil)assert(cd.f.nups==0)assert(cc.fs==nil)return cd.f end;function c:field(bA,aU)local bV=bA.fs;local ce={}d:exp2anyreg(bV,aU)b:next(bA)self:checkname(bA,ce)d:indexed(bV,aU,ce)end;function c:yindex(bA,aU)b:next(bA)self:expr(bA,aU)d:exp2val(bA.fs,aU)self:checknext(bA,"]")end;function c:recfield(bA,cf)local bV=bA.fs;local c9=bA.fs.freereg;local ce,cg={},{}if bA.t.token=="TK_NAME"then self:checklimit(bV,cf.nh,self.MAX_INT,"items in a constructor")self:checkname(bA,ce)else self:yindex(bA,ce)end;cf.nh=cf.nh+1;self:checknext(bA,"=")local ch=d:exp2RK(bV,ce)self:expr(bA,cg)d:codeABC(bV,"OP_SETTABLE",cf.t.info,ch,d:exp2RK(bV,cg))bV.freereg=c9 end;function c:closelistfield(bV,cf)if cf.v.k=="VVOID"then return end;d:exp2nextreg(bV,cf.v)cf.v.k="VVOID"if cf.tostore==e.LFIELDS_PER_FLUSH then d:setlist(bV,cf.t.info,cf.na,cf.tostore)cf.tostore=0 end end;function c:lastlistfield(bV,cf)if cf.tostore==0 then return end;if self:hasmultret(cf.v.k)then d:setmultret(bV,cf.v)d:setlist(bV,cf.t.info,cf.na,self.LUA_MULTRET)cf.na=cf.na-1 else if cf.v.k~="VVOID"then d:exp2nextreg(bV,cf.v)end;d:setlist(bV,cf.t.info,cf.na,cf.tostore)end end;function c:listfield(bA,cf)self:expr(bA,cf.v)self:checklimit(bA.fs,cf.na,self.MAX_INT,"items in a constructor")cf.na=cf.na+1;cf.tostore=cf.tostore+1 end;function c:constructor(bA,bn)local bV=bA.fs;local ci=bA.linenumber;local cj=d:codeABC(bV,"OP_NEWTABLE",0,0,0)local cf={}cf.v={}cf.na,cf.nh,cf.tostore=0,0,0;cf.t=bn;self:init_exp(bn,"VRELOCABLE",cj)self:init_exp(cf.v,"VVOID",0)d:exp2nextreg(bA.fs,bn)self:checknext(bA,"{")repeat assert(cf.v.k=="VVOID"or cf.tostore>0)if bA.t.token=="}"then break end;self:closelistfield(bV,cf)local aV=bA.t.token;if aV=="TK_NAME"then b:lookahead(bA)if bA.lookahead.token~="="then self:listfield(bA,cf)else self:recfield(bA,cf)end elseif aV=="["then self:recfield(bA,cf)else self:listfield(bA,cf)end until not self:testnext(bA,",")and not self:testnext(bA,";")self:check_match(bA,"}","{",ci)self:lastlistfield(bV,cf)e:SETARG_B(bV.f.code[cj],self:int2fb(cf.na))e:SETARG_C(bV.f.code[cj],self:int2fb(cf.nh))end;function c:parlist(bA)local bV=bA.fs;local b3=bV.f;local ck=0;b3.is_vararg=0;if bA.t.token~=")"then repeat local aV=bA.t.token;if aV=="TK_NAME"then self:new_localvar(bA,self:str_checkname(bA),ck)ck=ck+1 elseif aV=="TK_DOTS"then b:next(bA)self:new_localvarliteral(bA,"arg",ck)ck=ck+1;b3.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;b3.is_vararg=b3.is_vararg+self.VARARG_ISVARARG else b:syntaxerror(bA,"<name> or "..self:LUA_QL("...").." expected")end until b3.is_vararg~=0 or not self:testnext(bA,",")end;self:adjustlocalvars(bA,ck)b3.numparams=bV.nactvar-b3.is_vararg%self.HASARG_MASK;d:reserveregs(bV,bV.nactvar)end;function c:body(bA,bT,cl,ci)local cm={}cm.upvalues={}cm.actvar={}self:open_func(bA,cm)cm.f.lineDefined=ci;self:checknext(bA,"(")if cl then self:new_localvarliteral(bA,"self",0)self:adjustlocalvars(bA,1)end;self:parlist(bA)self:checknext(bA,")")self:chunk(bA)cm.f.lastlinedefined=bA.linenumber;self:check_match(bA,"TK_END","TK_FUNCTION",ci)self:close_func(bA)self:pushclosure(bA,cm,bT)end;function c:explist1(bA,aU)local b4=1;self:expr(bA,aU)while self:testnext(bA,",")do d:exp2nextreg(bA.fs,aU)self:expr(bA,aU)b4=b4+1 end;return b4 end;function c:funcargs(bA,b3)local bV=bA.fs;local cn={}local ck;local ci=bA.linenumber;local aV=bA.t.token;if aV=="("then if ci~=bA.lastline then b:syntaxerror(bA,"ambiguous syntax (function call x new statement)")end;b:next(bA)if bA.t.token==")"then cn.k="VVOID"else self:explist1(bA,cn)d:setmultret(bV,cn)end;self:check_match(bA,")","(",ci)elseif aV=="{"then self:constructor(bA,cn)elseif aV=="TK_STRING"then self:codestring(bA,cn,bA.t.seminfo)b:next(bA)else b:syntaxerror(bA,"function arguments expected")return end;assert(b3.k=="VNONRELOC")local c6=b3.info;if self:hasmultret(cn.k)then ck=self.LUA_MULTRET else if cn.k~="VVOID"then d:exp2nextreg(bV,cn)end;ck=bV.freereg-(c6+1)end;self:init_exp(b3,"VCALL",d:codeABC(bV,"OP_CALL",c6,ck+1,2))d:fixline(bV,ci)bV.freereg=c6+1 end;function c:prefixexp(bA,aU)local aV=bA.t.token;if aV=="("then local ci=bA.linenumber;b:next(bA)self:expr(bA,aU)self:check_match(bA,")","(",ci)d:dischargevars(bA.fs,aU)elseif aV=="TK_NAME"then self:singlevar(bA,aU)else b:syntaxerror(bA,"unexpected symbol")end;return end;function c:primaryexp(bA,aU)local bV=bA.fs;self:prefixexp(bA,aU)while true do local aV=bA.t.token;if aV=="."then self:field(bA,aU)elseif aV=="["then local ce={}d:exp2anyreg(bV,aU)self:yindex(bA,ce)d:indexed(bV,aU,ce)elseif aV==":"then local ce={}b:next(bA)self:checkname(bA,ce)d:_self(bV,aU,ce)self:funcargs(bA,aU)elseif aV=="("or aV=="TK_STRING"or aV=="{"then d:exp2nextreg(bV,aU)self:funcargs(bA,aU)else return end end end;function c:simpleexp(bA,aU)local aV=bA.t.token;if aV=="TK_NUMBER"then self:init_exp(aU,"VKNUM",0)aU.nval=bA.t.seminfo elseif aV=="TK_STRING"then self:codestring(bA,aU,bA.t.seminfo)elseif aV=="TK_NIL"then self:init_exp(aU,"VNIL",0)elseif aV=="TK_TRUE"then self:init_exp(aU,"VTRUE",0)elseif aV=="TK_FALSE"then self:init_exp(aU,"VFALSE",0)elseif aV=="TK_DOTS"then local bV=bA.fs;self:check_condition(bA,bV.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local co=bV.f.is_vararg;if co>=self.VARARG_NEEDSARG then bV.f.is_vararg=co-self.VARARG_NEEDSARG end;self:init_exp(aU,"VVARARG",d:codeABC(bV,"OP_VARARG",0,1,0))elseif aV=="{"then self:constructor(bA,aU)return elseif aV=="TK_FUNCTION"then b:next(bA)self:body(bA,aU,false,bA.linenumber)return else self:primaryexp(bA,aU)return end;b:next(bA)end;function c:getunopr(bk)if bk=="TK_NOT"then return"OPR_NOT"elseif bk=="-"then return"OPR_MINUS"elseif bk=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;c.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function c:getbinopr(bk)local cp=self.getbinopr_table[bk]if cp then return cp else return"OPR_NOBINOPR"end end;c.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}c.UNARY_PRIORITY=8;function c:subexpr(bA,aU,bS)self:enterlevel(bA)local cq=self:getunopr(bA.t.token)if cq~="OPR_NOUNOPR"then b:next(bA)self:subexpr(bA,aU,self.UNARY_PRIORITY)d:prefix(bA.fs,cq,aU)else self:simpleexp(bA,aU)end;local bk=self:getbinopr(bA.t.token)while bk~="OPR_NOBINOPR"and self.priority[d.BinOpr[bk]+1][1]>bS do local cr={}b:next(bA)d:infix(bA.fs,bk,aU)local cs=self:subexpr(bA,cr,self.priority[d.BinOpr[bk]+1][2])d:posfix(bA.fs,bk,aU,cr)bk=cs end;self:leavelevel(bA)return bk end;function c:expr(bA,aU)self:subexpr(bA,aU,0)end;function c:block_follow(bB)if bB=="TK_ELSE"or bB=="TK_ELSEIF"or bB=="TK_END"or bB=="TK_UNTIL"or bB=="TK_EOS"then return true else return false end end;function c:block(bA)local bV=bA.fs;local c4={}self:enterblock(bV,c4,false)self:chunk(bA)assert(c4.breaklist==d.NO_JUMP)self:leaveblock(bV)end;function c:check_conflict(bA,ct,aU)local bV=bA.fs;local c8=bV.freereg;local cu=false;while ct do if ct.v.k=="VINDEXED"then if ct.v.info==aU.info then cu=true;ct.v.info=c8 end;if ct.v.aux==aU.info then cu=true;ct.v.aux=c8 end end;ct=ct.prev end;if cu then d:codeABC(bV,"OP_MOVE",bV.freereg,aU.info,0)d:reserveregs(bV,1)end end;function c:assignment(bA,ct,c0)local bT={}local aV=ct.v.k;self:check_condition(bA,aV=="VLOCAL"or aV=="VUPVAL"or aV=="VGLOBAL"or aV=="VINDEXED","syntax error")if self:testnext(bA,",")then local cv={}cv.v={}cv.prev=ct;self:primaryexp(bA,cv.v)if cv.v.k=="VLOCAL"then self:check_conflict(bA,ct,cv.v)end;self:checklimit(bA.fs,c0,self.LUAI_MAXCCALLS-bA.L.nCcalls,"variables in assignment")self:assignment(bA,cv,c0+1)else self:checknext(bA,"=")local c7=self:explist1(bA,bT)if c7~=c0 then self:adjust_assign(bA,c0,c7,bT)if c7>c0 then bA.fs.freereg=bA.fs.freereg-(c7-c0)end else d:setoneret(bA.fs,bT)d:storevar(bA.fs,ct.v,bT)return end end;self:init_exp(bT,"VNONRELOC",bA.fs.freereg-1)d:storevar(bA.fs,ct.v,bT)end;function c:cond(bA)local aU={}self:expr(bA,aU)if aU.k=="VNIL"then aU.k="VFALSE"end;d:goiftrue(bA.fs,aU)return aU.f end;function c:breakstat(bA)local bV=bA.fs;local c4=bV.bl;local cw=false;while c4 and not c4.isbreakable do if c4.upval then cw=true end;c4=c4.previous end;if not c4 then b:syntaxerror(bA,"no loop to break")end;if cw then d:codeABC(bV,"OP_CLOSE",c4.nactvar,0,0)end;c4.breaklist=d:concat(bV,c4.breaklist,d:jump(bV))end;function c:whilestat(bA,ci)local bV=bA.fs;local c4={}b:next(bA)local cx=d:getlabel(bV)local cy=self:cond(bA)self:enterblock(bV,c4,true)self:checknext(bA,"TK_DO")self:block(bA)d:patchlist(bV,d:jump(bV),cx)self:check_match(bA,"TK_END","TK_WHILE",ci)self:leaveblock(bV)d:patchtohere(bV,cy)end;function c:repeatstat(bA,ci)local bV=bA.fs;local cz=d:getlabel(bV)local cA,cB={},{}self:enterblock(bV,cA,true)self:enterblock(bV,cB,false)b:next(bA)self:chunk(bA)self:check_match(bA,"TK_UNTIL","TK_REPEAT",ci)local cy=self:cond(bA)if not cB.upval then self:leaveblock(bV)d:patchlist(bA.fs,cy,cz)else self:breakstat(bA)d:patchtohere(bA.fs,cy)self:leaveblock(bV)d:patchlist(bA.fs,d:jump(bV),cz)end;self:leaveblock(bV)end;function c:exp1(bA)local bT={}self:expr(bA,bT)local bU=bT.k;d:exp2nextreg(bA.fs,bT)return bU end;function c:forbody(bA,c6,ci,c0,cC)local c4={}local bV=bA.fs;self:adjustlocalvars(bA,3)self:checknext(bA,"TK_DO")local cD=cC and d:codeAsBx(bV,"OP_FORPREP",c6,d.NO_JUMP)or d:jump(bV)self:enterblock(bV,c4,false)self:adjustlocalvars(bA,c0)d:reserveregs(bV,c0)self:block(bA)self:leaveblock(bV)d:patchtohere(bV,cD)local cE=cC and d:codeAsBx(bV,"OP_FORLOOP",c6,d.NO_JUMP)or d:codeABC(bV,"OP_TFORLOOP",c6,0,c0)d:fixline(bV,ci)d:patchlist(bV,cC and cE or d:jump(bV),cD+1)end;function c:fornum(bA,bZ,ci)local bV=bA.fs;local c6=bV.freereg;self:new_localvarliteral(bA,"(for index)",0)self:new_localvarliteral(bA,"(for limit)",1)self:new_localvarliteral(bA,"(for step)",2)self:new_localvar(bA,bZ,3)self:checknext(bA,'=')self:exp1(bA)self:checknext(bA,",")self:exp1(bA)if self:testnext(bA,",")then self:exp1(bA)else d:codeABx(bV,"OP_LOADK",bV.freereg,d:numberK(bV,1))d:reserveregs(bV,1)end;self:forbody(bA,c6,ci,1,true)end;function c:forlist(bA,cF)local bV=bA.fs;local bT={}local c0=0;local c6=bV.freereg;self:new_localvarliteral(bA,"(for generator)",c0)c0=c0+1;self:new_localvarliteral(bA,"(for state)",c0)c0=c0+1;self:new_localvarliteral(bA,"(for control)",c0)c0=c0+1;self:new_localvar(bA,cF,c0)c0=c0+1;while self:testnext(bA,",")do self:new_localvar(bA,self:str_checkname(bA),c0)c0=c0+1 end;self:checknext(bA,"TK_IN")local ci=bA.linenumber;self:adjust_assign(bA,3,self:explist1(bA,bT),bT)d:checkstack(bV,3)self:forbody(bA,c6,ci,c0-3,false)end;function c:forstat(bA,ci)local bV=bA.fs;local c4={}self:enterblock(bV,c4,true)b:next(bA)local bZ=self:str_checkname(bA)local aV=bA.t.token;if aV=="="then self:fornum(bA,bZ,ci)elseif aV==","or aV=="TK_IN"then self:forlist(bA,bZ)else b:syntaxerror(bA,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(bA,"TK_END","TK_FOR",ci)self:leaveblock(bV)end;function c:test_then_block(bA)b:next(bA)local cy=self:cond(bA)self:checknext(bA,"TK_THEN")self:block(bA)return cy end;function c:ifstat(bA,ci)local bV=bA.fs;local cG=d.NO_JUMP;local cH=self:test_then_block(bA)while bA.t.token=="TK_ELSEIF"do cG=d:concat(bV,cG,d:jump(bV))d:patchtohere(bV,cH)cH=self:test_then_block(bA)end;if bA.t.token=="TK_ELSE"then cG=d:concat(bV,cG,d:jump(bV))d:patchtohere(bV,cH)b:next(bA)self:block(bA)else cG=d:concat(bV,cG,cH)end;d:patchtohere(bV,cG)self:check_match(bA,"TK_END","TK_IF",ci)end;function c:localfunc(bA)local aU,b0={},{}local bV=bA.fs;self:new_localvar(bA,self:str_checkname(bA),0)self:init_exp(aU,"VLOCAL",bV.freereg)d:reserveregs(bV,1)self:adjustlocalvars(bA,1)self:body(bA,b0,false,bA.linenumber)d:storevar(bV,aU,b0)self:getlocvar(bV,bV.nactvar-1).startpc=bV.pc end;function c:localstat(bA)local c0=0;local c7;local bT={}repeat self:new_localvar(bA,self:str_checkname(bA),c0)c0=c0+1 until not self:testnext(bA,",")if self:testnext(bA,"=")then c7=self:explist1(bA,bT)else bT.k="VVOID"c7=0 end;self:adjust_assign(bA,c0,c7,bT)self:adjustlocalvars(bA,c0)end;function c:funcname(bA,aU)local cl=false;self:singlevar(bA,aU)while bA.t.token=="."do self:field(bA,aU)end;if bA.t.token==":"then cl=true;self:field(bA,aU)end;return cl end;function c:funcstat(bA,ci)local aU,b0={},{}b:next(bA)local cl=self:funcname(bA,aU)self:body(bA,b0,cl,ci)d:storevar(bA.fs,aU,b0)d:fixline(bA.fs,ci)end;function c:exprstat(bA)local bV=bA.fs;local aU={}aU.v={}self:primaryexp(bA,aU.v)if aU.v.k=="VCALL"then e:SETARG_C(d:getcode(bV,aU.v),1)else aU.prev=nil;self:assignment(bA,aU,1)end end;function c:retstat(bA)local bV=bA.fs;local bT={}local bx,cI;b:next(bA)if self:block_follow(bA.t.token)or bA.t.token==";"then bx,cI=0,0 else cI=self:explist1(bA,bT)if self:hasmultret(bT.k)then d:setmultret(bV,bT)if bT.k=="VCALL"and cI==1 then e:SET_OPCODE(d:getcode(bV,bT),"OP_TAILCALL")assert(e:GETARG_A(d:getcode(bV,bT))==bV.nactvar)end;bx=bV.nactvar;cI=self.LUA_MULTRET else if cI==1 then bx=d:exp2anyreg(bV,bT)else d:exp2nextreg(bV,bT)bx=bV.nactvar;assert(cI==bV.freereg-bx)end end end;d:ret(bV,bx,cI)end;function c:statement(bA)local ci=bA.linenumber;local aV=bA.t.token;if aV=="TK_IF"then self:ifstat(bA,ci)return false elseif aV=="TK_WHILE"then self:whilestat(bA,ci)return false elseif aV=="TK_DO"then b:next(bA)self:block(bA)self:check_match(bA,"TK_END","TK_DO",ci)return false elseif aV=="TK_FOR"then self:forstat(bA,ci)return false elseif aV=="TK_REPEAT"then self:repeatstat(bA,ci)return false elseif aV=="TK_FUNCTION"then self:funcstat(bA,ci)return false elseif aV=="TK_LOCAL"then b:next(bA)if self:testnext(bA,"TK_FUNCTION")then self:localfunc(bA)else self:localstat(bA)end;return false elseif aV=="TK_RETURN"then self:retstat(bA)return true elseif aV=="TK_BREAK"then b:next(bA)self:breakstat(bA)return true else self:exprstat(bA)return false end end;function c:chunk(bA)local cJ=false;self:enterlevel(bA)while not cJ and not self:block_follow(bA.t.token)do cJ=self:statement(bA)self:testnext(bA,";")assert(bA.fs.f.maxstacksize>=bA.fs.freereg and bA.fs.freereg>=bA.fs.nactvar)bA.fs.freereg=bA.fs.nactvar end;self:leavelevel(bA)end;d.MAXSTACK=250;function d:ttisnumber(aQ)if aQ then return type(aQ.value)=="number"else return false end end;function d:nvalue(aQ)return aQ.value end;function d:setnilvalue(aQ)aQ.value=nil end;function d:setsvalue(aQ,aS)aQ.value=aS end;d.setnvalue=d.setsvalue;d.sethvalue=d.setsvalue;d.setbvalue=d.setsvalue;function d:numadd(bd,b0)return bd+b0 end;function d:numsub(bd,b0)return bd-b0 end;function d:nummul(bd,b0)return bd*b0 end;function d:numdiv(bd,b0)return bd/b0 end;function d:nummod(bd,b0)return bd%b0 end;function d:numpow(bd,b0)return bd^b0 end;function d:numunm(bd)return-bd end;function d:numisnan(bd)return not bd==bd end;d.NO_JUMP=-1;d.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}d.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function d:getcode(bV,bT)return bV.f.code[bT.info]end;function d:codeAsBx(bV,aQ,ap,cK)return self:codeABx(bV,aQ,ap,cK+e.MAXARG_sBx)end;function d:setmultret(bV,bT)self:setreturns(bV,bT,c.LUA_MULTRET)end;function d:hasjumps(bT)return bT.t~=bT.f end;function d:isnumeral(bT)return bT.k=="VKNUM"and bT.t==self.NO_JUMP and bT.f==self.NO_JUMP end;function d:_nil(bV,bH,b4)if bV.pc>bV.lasttarget then if bV.pc==0 then if bH>=bV.nactvar then return end else local cL=bV.f.code[bV.pc-1]if e:GET_OPCODE(cL)=="OP_LOADNIL"then local cM=e:GETARG_A(cL)local cN=e:GETARG_B(cL)if cM<=bH and bH<=cN+1 then if bH+b4-1>cN then e:SETARG_B(cL,bH+b4-1)end;return end end end end;self:codeABC(bV,"OP_LOADNIL",bH,bH+b4-1,0)end;function d:jump(bV)local cO=bV.jpc;bV.jpc=self.NO_JUMP;local cP=self:codeAsBx(bV,"OP_JMP",0,self.NO_JUMP)cP=self:concat(bV,cP,cO)return cP end;function d:ret(bV,bx,cI)self:codeABC(bV,"OP_RETURN",bx,cI+1,0)end;function d:condjump(bV,bk,ap,ao,an)self:codeABC(bV,bk,ap,ao,an)return self:jump(bV)end;function d:fixjump(bV,cj,cQ)local cR=bV.f.code[cj]local cS=cQ-(cj+1)assert(cQ~=self.NO_JUMP)if math.abs(cS)>e.MAXARG_sBx then b:syntaxerror(bV.ls,"control structure too long")end;e:SETARG_sBx(cR,cS)end;function d:getlabel(bV)bV.lasttarget=bV.pc;return bV.pc end;function d:getjump(bV,cj)local cS=e:GETARG_sBx(bV.f.code[cj])if cS==self.NO_JUMP then return self.NO_JUMP else return cj+1+cS end end;function d:getjumpcontrol(bV,cj)local cT=bV.f.code[cj]local cU=bV.f.code[cj-1]if cj>=1 and e:testTMode(e:GET_OPCODE(cU))~=0 then return cU else return cT end end;function d:need_value(bV,cV)while cV~=self.NO_JUMP do local a_=self:getjumpcontrol(bV,cV)if e:GET_OPCODE(a_)~="OP_TESTSET"then return true end;cV=self:getjump(bV,cV)end;return false end;function d:patchtestreg(bV,cW,c9)local a_=self:getjumpcontrol(bV,cW)if e:GET_OPCODE(a_)~="OP_TESTSET"then return false end;if c9~=e.NO_REG and c9~=e:GETARG_B(a_)then e:SETARG_A(a_,c9)else e:SET_OPCODE(a_,"OP_TEST")local b0=e:GETARG_B(a_)e:SETARG_A(a_,b0)e:SETARG_B(a_,0)end;return true end;function d:removevalues(bV,cV)while cV~=self.NO_JUMP do self:patchtestreg(bV,cV,e.NO_REG)cV=self:getjump(bV,cV)end end;function d:patchlistaux(bV,cV,cX,c9,cY)while cV~=self.NO_JUMP do local cZ=self:getjump(bV,cV)if self:patchtestreg(bV,cV,c9)then self:fixjump(bV,cV,cX)else self:fixjump(bV,cV,cY)end;cV=cZ end end;function d:dischargejpc(bV)self:patchlistaux(bV,bV.jpc,bV.pc,e.NO_REG,bV.pc)bV.jpc=self.NO_JUMP end;function d:patchlist(bV,cV,c_)if c_==bV.pc then self:patchtohere(bV,cV)else assert(c_<bV.pc)self:patchlistaux(bV,cV,c_,e.NO_REG,c_)end end;function d:patchtohere(bV,cV)self:getlabel(bV)bV.jpc=self:concat(bV,bV.jpc,cV)end;function d:concat(bV,d0,d1)if d1==self.NO_JUMP then return d0 elseif d0==self.NO_JUMP then return d1 else local cV=d0;local cZ=self:getjump(bV,cV)while cZ~=self.NO_JUMP do cV=cZ;cZ=self:getjump(bV,cV)end;self:fixjump(bV,cV,d1)end;return d0 end;function d:checkstack(bV,b4)local d2=bV.freereg+b4;if d2>bV.f.maxstacksize then if d2>=self.MAXSTACK then b:syntaxerror(bV.ls,"function or expression too complex")end;bV.f.maxstacksize=d2 end end;function d:reserveregs(bV,b4)self:checkstack(bV,b4)bV.freereg=bV.freereg+b4 end;function d:freereg(bV,c9)if not e:ISK(c9)and c9>=bV.nactvar then bV.freereg=bV.freereg-1;assert(c9==bV.freereg)end end;function d:freeexp(bV,bT)if bT.k=="VNONRELOC"then self:freereg(bV,bT.info)end end;function d:addk(bV,bU,aU)local b8=bV.L;local d3=bV.h[bU.value]local b3=bV.f;if self:ttisnumber(d3)then return self:nvalue(d3)else d3={}self:setnvalue(d3,bV.nk)bV.h[bU.value]=d3;c:growvector(b8,b3.k,bV.nk,b3.sizek,nil,e.MAXARG_Bx,"constant table overflow")b3.k[bV.nk]=aU;local d4=bV.nk;bV.nk=bV.nk+1;return d4 end end;function d:stringK(bV,aP)local aQ={}self:setsvalue(aQ,aP)return self:addk(bV,aQ,aQ)end;function d:numberK(bV,d5)local aQ={}self:setnvalue(aQ,d5)return self:addk(bV,aQ,aQ)end;function d:boolK(bV,b0)local aQ={}self:setbvalue(aQ,b0)return self:addk(bV,aQ,aQ)end;function d:nilK(bV)local bU,aU={},{}self:setnilvalue(aU)self:sethvalue(bU,bV.h)return self:addk(bV,bU,aU)end;function d:setreturns(bV,bT,d6)if bT.k=="VCALL"then e:SETARG_C(self:getcode(bV,bT),d6+1)elseif bT.k=="VVARARG"then e:SETARG_B(self:getcode(bV,bT),d6+1)e:SETARG_A(self:getcode(bV,bT),bV.freereg)d:reserveregs(bV,1)end end;function d:setoneret(bV,bT)if bT.k=="VCALL"then bT.k="VNONRELOC"bT.info=e:GETARG_A(self:getcode(bV,bT))elseif bT.k=="VVARARG"then e:SETARG_B(self:getcode(bV,bT),2)bT.k="VRELOCABLE"end end;function d:dischargevars(bV,bT)local bU=bT.k;if bU=="VLOCAL"then bT.k="VNONRELOC"elseif bU=="VUPVAL"then bT.info=self:codeABC(bV,"OP_GETUPVAL",0,bT.info,0)bT.k="VRELOCABLE"elseif bU=="VGLOBAL"then bT.info=self:codeABx(bV,"OP_GETGLOBAL",0,bT.info)bT.k="VRELOCABLE"elseif bU=="VINDEXED"then self:freereg(bV,bT.aux)self:freereg(bV,bT.info)bT.info=self:codeABC(bV,"OP_GETTABLE",0,bT.info,bT.aux)bT.k="VRELOCABLE"elseif bU=="VVARARG"or bU=="VCALL"then self:setoneret(bV,bT)else end end;function d:code_label(bV,ap,b0,d7)self:getlabel(bV)return self:codeABC(bV,"OP_LOADBOOL",ap,b0,d7)end;function d:discharge2reg(bV,bT,c9)self:dischargevars(bV,bT)local bU=bT.k;if bU=="VNIL"then self:_nil(bV,c9,1)elseif bU=="VFALSE"or bU=="VTRUE"then self:codeABC(bV,"OP_LOADBOOL",c9,bT.k=="VTRUE"and 1 or 0,0)elseif bU=="VK"then self:codeABx(bV,"OP_LOADK",c9,bT.info)elseif bU=="VKNUM"then self:codeABx(bV,"OP_LOADK",c9,self:numberK(bV,bT.nval))elseif bU=="VRELOCABLE"then local cj=self:getcode(bV,bT)e:SETARG_A(cj,c9)elseif bU=="VNONRELOC"then if c9~=bT.info then self:codeABC(bV,"OP_MOVE",c9,bT.info,0)end else assert(bT.k=="VVOID"or bT.k=="VJMP")return end;bT.info=c9;bT.k="VNONRELOC"end;function d:discharge2anyreg(bV,bT)if bT.k~="VNONRELOC"then self:reserveregs(bV,1)self:discharge2reg(bV,bT,bV.freereg-1)end end;function d:exp2reg(bV,bT,c9)self:discharge2reg(bV,bT,c9)if bT.k=="VJMP"then bT.t=self:concat(bV,bT.t,bT.info)end;if self:hasjumps(bT)then local d8;local d9=self.NO_JUMP;local da=self.NO_JUMP;if self:need_value(bV,bT.t)or self:need_value(bV,bT.f)then local db=bT.k=="VJMP"and self.NO_JUMP or self:jump(bV)d9=self:code_label(bV,c9,0,1)da=self:code_label(bV,c9,1,0)self:patchtohere(bV,db)end;d8=self:getlabel(bV)self:patchlistaux(bV,bT.f,d8,c9,d9)self:patchlistaux(bV,bT.t,d8,c9,da)end;bT.f,bT.t=self.NO_JUMP,self.NO_JUMP;bT.info=c9;bT.k="VNONRELOC"end;function d:exp2nextreg(bV,bT)self:dischargevars(bV,bT)self:freeexp(bV,bT)self:reserveregs(bV,1)self:exp2reg(bV,bT,bV.freereg-1)end;function d:exp2anyreg(bV,bT)self:dischargevars(bV,bT)if bT.k=="VNONRELOC"then if not self:hasjumps(bT)then return bT.info end;if bT.info>=bV.nactvar then self:exp2reg(bV,bT,bT.info)return bT.info end end;self:exp2nextreg(bV,bT)return bT.info end;function d:exp2val(bV,bT)if self:hasjumps(bT)then self:exp2anyreg(bV,bT)else self:dischargevars(bV,bT)end end;function d:exp2RK(bV,bT)self:exp2val(bV,bT)local bU=bT.k;if bU=="VKNUM"or bU=="VTRUE"or bU=="VFALSE"or bU=="VNIL"then if bV.nk<=e.MAXINDEXRK then if bT.k=="VNIL"then bT.info=self:nilK(bV)else bT.info=bT.k=="VKNUM"and self:numberK(bV,bT.nval)or self:boolK(bV,bT.k=="VTRUE")end;bT.k="VK"return e:RKASK(bT.info)end elseif bU=="VK"then if bT.info<=e.MAXINDEXRK then return e:RKASK(bT.info)end else end;return self:exp2anyreg(bV,bT)end;function d:storevar(bV,c5,dc)local bU=c5.k;if bU=="VLOCAL"then self:freeexp(bV,dc)self:exp2reg(bV,dc,c5.info)return elseif bU=="VUPVAL"then local bT=self:exp2anyreg(bV,dc)self:codeABC(bV,"OP_SETUPVAL",bT,c5.info,0)elseif bU=="VGLOBAL"then local bT=self:exp2anyreg(bV,dc)self:codeABx(bV,"OP_SETGLOBAL",bT,c5.info)elseif bU=="VINDEXED"then local bT=self:exp2RK(bV,dc)self:codeABC(bV,"OP_SETTABLE",c5.info,c5.aux,bT)else assert(0)end;self:freeexp(bV,dc)end;function d:_self(bV,bT,ce)self:exp2anyreg(bV,bT)self:freeexp(bV,bT)local cb=bV.freereg;self:reserveregs(bV,2)self:codeABC(bV,"OP_SELF",cb,bT.info,self:exp2RK(bV,ce))self:freeexp(bV,ce)bT.info=cb;bT.k="VNONRELOC"end;function d:invertjump(bV,bT)local cj=self:getjumpcontrol(bV,bT.info)assert(e:testTMode(e:GET_OPCODE(cj))~=0 and e:GET_OPCODE(cj)~="OP_TESTSET"and e:GET_OPCODE(cj)~="OP_TEST")e:SETARG_A(cj,e:GETARG_A(cj)==0 and 1 or 0)end;function d:jumponcond(bV,bT,dd)if bT.k=="VRELOCABLE"then local de=self:getcode(bV,bT)if e:GET_OPCODE(de)=="OP_NOT"then bV.pc=bV.pc-1;return self:condjump(bV,"OP_TEST",e:GETARG_B(de),0,dd and 0 or 1)end end;self:discharge2anyreg(bV,bT)self:freeexp(bV,bT)return self:condjump(bV,"OP_TESTSET",e.NO_REG,bT.info,dd and 1 or 0)end;function d:goiftrue(bV,bT)local cj;self:dischargevars(bV,bT)local bU=bT.k;if bU=="VK"or bU=="VKNUM"or bU=="VTRUE"then cj=self.NO_JUMP elseif bU=="VFALSE"then cj=self:jump(bV)elseif bU=="VJMP"then self:invertjump(bV,bT)cj=bT.info else cj=self:jumponcond(bV,bT,false)end;bT.f=self:concat(bV,bT.f,cj)self:patchtohere(bV,bT.t)bT.t=self.NO_JUMP end;function d:goiffalse(bV,bT)local cj;self:dischargevars(bV,bT)local bU=bT.k;if bU=="VNIL"or bU=="VFALSE"then cj=self.NO_JUMP elseif bU=="VTRUE"then cj=self:jump(bV)elseif bU=="VJMP"then cj=bT.info else cj=self:jumponcond(bV,bT,true)end;bT.t=self:concat(bV,bT.t,cj)self:patchtohere(bV,bT.f)bT.f=self.NO_JUMP end;function d:codenot(bV,bT)self:dischargevars(bV,bT)local bU=bT.k;if bU=="VNIL"or bU=="VFALSE"then bT.k="VTRUE"elseif bU=="VK"or bU=="VKNUM"or bU=="VTRUE"then bT.k="VFALSE"elseif bU=="VJMP"then self:invertjump(bV,bT)elseif bU=="VRELOCABLE"or bU=="VNONRELOC"then self:discharge2anyreg(bV,bT)self:freeexp(bV,bT)bT.info=self:codeABC(bV,"OP_NOT",0,bT.info,0)bT.k="VRELOCABLE"else assert(0)end;bT.f,bT.t=bT.t,bT.f;self:removevalues(bV,bT.f)self:removevalues(bV,bT.t)end;function d:indexed(bV,bn,bU)bn.aux=self:exp2RK(bV,bU)bn.k="VINDEXED"end;function d:constfolding(bk,df,dg)local d5;if not self:isnumeral(df)or not self:isnumeral(dg)then return false end;local dh=df.nval;local cr=dg.nval;if bk=="OP_ADD"then d5=self:numadd(dh,cr)elseif bk=="OP_SUB"then d5=self:numsub(dh,cr)elseif bk=="OP_MUL"then d5=self:nummul(dh,cr)elseif bk=="OP_DIV"then if cr==0 then return false end;d5=self:numdiv(dh,cr)elseif bk=="OP_MOD"then if cr==0 then return false end;d5=self:nummod(dh,cr)elseif bk=="OP_POW"then d5=self:numpow(dh,cr)elseif bk=="OP_UNM"then d5=self:numunm(dh)elseif bk=="OP_LEN"then return false else assert(0)d5=0 end;if self:numisnan(d5)then return false end;df.nval=d5;return true end;function d:codearith(bV,bk,df,dg)if self:constfolding(bk,df,dg)then return else local di=bk~="OP_UNM"and bk~="OP_LEN"and self:exp2RK(bV,dg)or 0;local dj=self:exp2RK(bV,df)if dj>di then self:freeexp(bV,df)self:freeexp(bV,dg)else self:freeexp(bV,dg)self:freeexp(bV,df)end;df.info=self:codeABC(bV,bk,0,dj,di)df.k="VRELOCABLE"end end;function d:codecomp(bV,bk,dd,df,dg)local dj=self:exp2RK(bV,df)local di=self:exp2RK(bV,dg)self:freeexp(bV,dg)self:freeexp(bV,df)if dd==0 and bk~="OP_EQ"then dj,di=di,dj;dd=1 end;df.info=self:condjump(bV,bk,dd,dj,di)df.k="VJMP"end;function d:prefix(bV,bk,bT)local dg={}dg.t,dg.f=self.NO_JUMP,self.NO_JUMP;dg.k="VKNUM"dg.nval=0;if bk=="OPR_MINUS"then if not self:isnumeral(bT)then self:exp2anyreg(bV,bT)end;self:codearith(bV,"OP_UNM",bT,dg)elseif bk=="OPR_NOT"then self:codenot(bV,bT)elseif bk=="OPR_LEN"then self:exp2anyreg(bV,bT)self:codearith(bV,"OP_LEN",bT,dg)else assert(0)end end;function d:infix(bV,bk,aU)if bk=="OPR_AND"then self:goiftrue(bV,aU)elseif bk=="OPR_OR"then self:goiffalse(bV,aU)elseif bk=="OPR_CONCAT"then self:exp2nextreg(bV,aU)elseif bk=="OPR_ADD"or bk=="OPR_SUB"or bk=="OPR_MUL"or bk=="OPR_DIV"or bk=="OPR_MOD"or bk=="OPR_POW"then if not self:isnumeral(aU)then self:exp2RK(bV,aU)end else self:exp2RK(bV,aU)end end;d.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}d.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}d.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function d:posfix(bV,bk,df,dg)local function dk(df,dg)df.k=dg.k;df.info=dg.info;df.aux=dg.aux;df.nval=dg.nval;df.t=dg.t;df.f=dg.f end;if bk=="OPR_AND"then assert(df.t==self.NO_JUMP)self:dischargevars(bV,dg)dg.f=self:concat(bV,dg.f,df.f)dk(df,dg)elseif bk=="OPR_OR"then assert(df.f==self.NO_JUMP)self:dischargevars(bV,dg)dg.t=self:concat(bV,dg.t,df.t)dk(df,dg)elseif bk=="OPR_CONCAT"then self:exp2val(bV,dg)if dg.k=="VRELOCABLE"and e:GET_OPCODE(self:getcode(bV,dg))=="OP_CONCAT"then assert(df.info==e:GETARG_B(self:getcode(bV,dg))-1)self:freeexp(bV,df)e:SETARG_B(self:getcode(bV,dg),df.info)df.k="VRELOCABLE"df.info=dg.info else self:exp2nextreg(bV,dg)self:codearith(bV,"OP_CONCAT",df,dg)end else local dl=self.arith_op[bk]if dl then self:codearith(bV,dl,df,dg)else local dm=self.comp_op[bk]if dm then self:codecomp(bV,dm,self.comp_cond[bk],df,dg)else assert(0)end end end end;function d:fixline(bV,ci)bV.f.lineinfo[bV.pc-1]=ci end;function d:code(bV,a_,ci)local b3=bV.f;self:dischargejpc(bV)c:growvector(bV.L,b3.code,bV.pc,b3.sizecode,nil,c.MAX_INT,"code size overflow")b3.code[bV.pc]=a_;c:growvector(bV.L,b3.lineinfo,bV.pc,b3.sizelineinfo,nil,c.MAX_INT,"code size overflow")b3.lineinfo[bV.pc]=ci;local cj=bV.pc;bV.pc=bV.pc+1;return cj end;function d:codeABC(bV,aQ,bd,b0,aV)assert(e:getOpMode(aQ)==e.OpMode.iABC)assert(e:getBMode(aQ)~=e.OpArgMask.OpArgN or b0==0)assert(e:getCMode(aQ)~=e.OpArgMask.OpArgN or aV==0)return self:code(bV,e:CREATE_ABC(aQ,bd,b0,aV),bV.ls.lastline)end;function d:codeABx(bV,aQ,bd,be)assert(e:getOpMode(aQ)==e.OpMode.iABx or e:getOpMode(aQ)==e.OpMode.iAsBx)assert(e:getCMode(aQ)==e.OpArgMask.OpArgN)return self:code(bV,e:CREATE_ABx(aQ,bd,be),bV.ls.lastline)end;function d:setlist(bV,c6,bQ,dn)local aV=math.floor((bQ-1)/e.LFIELDS_PER_FLUSH)+1;local b0=dn==c.LUA_MULTRET and 0 or dn;assert(dn~=0)if aV<=e.MAXARG_C then self:codeABC(bV,"OP_SETLIST",c6,b0,aV)else self:codeABC(bV,"OP_SETLIST",c6,b0,0)self:code(bV,e:CREATE_Inst(aV),bV.ls.lastline)end;bV.freereg=c6+1 end;b:init()local dp={}getfenv().script=nil;function jpgdkl(bu,dq)local b3,aO,aN,bp;dq=dq or getfenv(2)bp="you smell like a dumpster :)"local dr,error=pcall(function()local ds=a:init(a:make_getS(bu),nil)if not ds then return error()end;local cb=c:parser(dp,ds,nil,bp or"::Adonis::Loadstring::")aO,aN=f:make_setS()f:dump(dp,cb,aO,aN)b3=g:wrappermix(aN.data,dq)end)if dr then return b3,aN.data else return nil,error end end return function(klp) jpgdkl(klp)() end 
